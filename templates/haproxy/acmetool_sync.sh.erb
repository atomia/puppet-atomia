#!/bin/sh

PATH=$PATH:/usr/sbin
export PATH

ATO_NETS="<%= @apache_cluster_ip %>/32"

# Setting up the script to support local and remote
<% if @haproxy_nodes.split(",")[0].downcase == @hostname %>
LB_REMOTE="<%= @haproxy_nodes.split(",")[1] %>"
LB_LOCAL="<%= @haproxy_nodes.split(",")[0] %>"
<% else %>
LB_REMOTE="<%= @haproxy_nodes.split(",")[0] %>"
LB_LOCAL="<%= @haproxy_nodes.split(",")[1] %>"
<% end %>

certbot="/usr/bin/certbot"
wanted_cert_path="/etc/letsencrypt/live"
synced_apache_config="/etc/haproxy/synced_apache_config"
synced_iis_config="/etc/haproxy/synced_iis_config"
NEW_CERTS=0

if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        echo "usage: $0 rsync_path_to_apache_config rsync_path_to_iis_config preview_domain"
        echo "example:"
        echo "$0 \"root@192.168.33.21:/storage/configuration/maps\" \"root@192.168.33.21:/storage/configuration/iis\" preview.dev.atomia.com"
        exit 1
fi

# If the ATO_NETS ip is not binded then we need to exit the script as this nodes does not have binded IP
ip a | grep $ATO_NETS > /dev/null
BINDED=$?
if [ $BINDED -eq 1 ]
then
    logger "Skipping issuing of LE certs, as this nodes does not have apache cluster ip!"
    logger "Doing only rsync from the primary load balancer $LB_REMOTE"

    # We now need to sync our certificates from the LB_REMOTE node as we are not on the main node
    # In order for sync to work a certbot user needs to be created on both nodes with the same key
    # That user should also have sudo privileges without a password
    # Also the certbot private key needs to be added to /root/.ssh/certbot
    if [ -n "$LB_REMOTE" ] 
    then
        # Try to login via SSH without password to the remote LB node and pull the certs
        ssh -o PasswordAuthentication=no -o BatchMode=yes certbot@$LB_REMOTE -p 2022 -i /root/.ssh/certbot exit &>/dev/null
        if [ $? -eq 0 ]
        then
            # Login success, we are able to login with key to the node
            # Rsync pull certs from remote node primary LB
            # In order for rsync to work via certbot user we need to add
            # the certbot to sudoers certbot ALL= NOPASSWD:/usr/bin/rsync
            logger "Rsync now from $LB_REMOTE"

            rsync -a -e "ssh -o StrictHostKeyChecking=no -i /root/.ssh/certbot -p 2022" --rsync-path="sudo rsync" "certbot@$LB_REMOTE:/etc/haproxy/le_certs/" /etc/haproxy/le_certs/
            rsync -a -e "ssh -o StrictHostKeyChecking=no -i /root/.ssh/certbot -p 2022" --rsync-path="sudo rsync" "certbot@$LB_REMOTE:/etc/letsencrypt/archive/" /etc/letsencrypt/archive/
            rsync -a -e "ssh -o StrictHostKeyChecking=no -i /root/.ssh/certbot -p 2022" --rsync-path="sudo rsync" "certbot@$LB_REMOTE:/etc/letsencrypt/renewal/" /etc/letsencrypt/renewal/
            rsync -a -e "ssh -o StrictHostKeyChecking=no -i /root/.ssh/certbot -p 2022" --rsync-path="sudo rsync" "certbot@$LB_REMOTE:/etc/letsencrypt/live/" /etc/letsencrypt/live/
            
            logger "Reloading Haproxy"
            service haproxy reload
        else
            # Login failed, we will not sync
            logger "Could not login to $LB_REMOTE, skipping sync of LE certificates!"
        fi
    fi
    exit 1
fi

#get all ips
CURRENT_IPS=$`hostname -I`

#convert to newlines and sort files for comm command
echo $ATO_NETS | tr " " "\n" | sort > /tmp/l1.tmp
echo $CURRENT_IPS | tr " " "\n" | sort > /tmp/l2.tmp

#append /32 on all IPS that hostname -I returns
sed -e 's/$/\/32/' -i /tmp/l2.tmp

#create new ATO_NETS with lines that match both
ATO_NETS=`comm -12 /tmp/l1.tmp /tmp/l2.tmp | tr "\n" " "`

#remove temp files
rm /tmp/l1.tmp /tmp/l2.tmp

#check if ATO_NETS is empty
if [ -z $ATO_NETS ]
then
        echo "Empty ATO_NETS, Reloading haproxy"
        service haproxy reload
        echo "Reloading done, now exiting"
        exit
fi

# Sync all files from /storage/content/ssl to local dir
rsync -a -e "ssh -o StrictHostKeyChecking=no" --delete "$1"/ "$synced_apache_config"
#rsync -a -e "ssh -o StrictHostKeyChecking=no" --delete "$2"/ "$synced_iis_config"

in_net() {
        perl -e '
use strict;

my $net = shift @ARGV or die "no net";
my $ip = shift @ARGV or die "no ip";

my @pair = split("/", $net);
my $pf = $pair[0];
my $pl = $pair[1];

$pf =~ s/(\d+)([.]|$)/sprintf("%02X", $1)/ge;
$pf = unpack("N", pack("H8", $pf));
$pl = unpack("N", pack("b32", "1" x $pl . "0" x (32 - $pl)));

$ip =~ s/(\d+)([.]|$)/sprintf("%02X", $1)/ge;
$ip = unpack("N", pack("H8", $ip));

exit 1 if ($pf & $pl) ne ($ip & $pl);
' "$1" "$2"
}

in_ato_nets() {
        is_in=no
        for net in $ATO_NETS; do
                in_net $net "$1" && {
                        is_in=yes
                        break
                }
        done
        echo $is_in
}

if [ -f "$synced_apache_config/vhost.map" ]; then
        cat "$synced_apache_config"/vhost.map | awk '{ print $1 }' | grep -vE "$3"'$' | grep -v '^www\.' | grep -E '^[a-zA-Z0-9.-]+$' \
                        | sort -u | awk '{ print $0 " www." $0 }' | while read cert; do
                wanted_cert=$(echo "$cert" | cut -d " " -f 1)
                wanted_wwwcert=$(echo "$cert" | cut -d " " -f 2 )
                desired=$(echo "$cert" | cut -d " " -f 1 )
                #echo $wanted_cert $wanted_wwwcert $desired
                if [ ! -d `echo "$wanted_cert_path/$desired"` ]; then
                        # We force 8.8.8.8 because sometimes our DNS does not propagate
                        # all records immediateley, it's better to ask the outside DNS
                        # just to be sure that everything has been propagated before
                        # issuing the SSL certificate
                        ip1="$(dig +short $wanted_wwwcert @8.8.8.8 | grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b')"
                        ip2="$(dig +short $wanted_cert @8.8.8.8 | head -1)"

                                if  [ -n "$ip1" ] && [ "$(in_ato_nets $ip1)" = yes ] && [ -n "$ip2" ] && [ "$(in_ato_nets $ip2)" = yes ] ; then
                                        echo "$wanted_cert_path/$desired"
                                        #echo "wanted cert: $wanted_cert"
                                        #echo "www cert: $wwwcert"
                                        certbot certonly --webroot -w /tmp -d $wanted_cert -d $wanted_wwwcert --non-interactive --agree-tos --email noreply@atomia.com
                                        if [ -d `echo "$wanted_cert_path/$desired"` ]; then
                                                echo "Issuing $wanted_cert"
                                                sudo -E bash -c "cat /etc/letsencrypt/live/$wanted_cert/fullchain.pem /etc/letsencrypt/live/$wanted_cert/privkey.pem > /etc/haproxy/le_certs/$wanted_cert.pem"
                                                chmod 600 /etc/haproxy/le_certs/$wanted_cert.pem
                                                rm /var/log/letsencrypt/letsencrypt.log
                                                find /var/log/letsencrypt/ -size 0 -delete
                                        fi
                                fi
                fi
        done

        #Delete broken PEMs
        find /etc/haproxy/le_certs/ -size 0 -delete

        #If there is at least one new cert, reload haproxy
#       if [ "$NEW_CERTS" -ge "1" ]; then
                echo "Reloading haproxy"
                service haproxy reload
                echo "Reloading done"
#       fi
fi

exit 0